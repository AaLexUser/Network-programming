# 13. Виды мьютексов и их отличия

## `mutex`
**Описание**: Базовый мьютекс, который может быть захвачен только одним потоком. Если другой поток попытается захватить мьютекс, он будет заблокирован до тех пор, пока мьютекс не будет освобожден.

**Особенности**:

- Не поддерживает рекурсивный захват (один поток не может захватить мьютекс несколько раз).
- Не поддерживает таймауты или попытки захвата с ограничением по времени.

## `recursive_mutex`
**Описание**:

- Позволяет одному и тому же потоку повторно захватывать мьютекс несколько раз, не блокируясь при этом самому на себе.
- Счётчик рекурсивных захватов увеличивается при каждом `lock()`, и уменьшается при `unlock()`. Освобождение мьютекса происходит только когда счётчик достигнет нуля.

**Плюсы**:

- Подходит для случаев, когда функция, захватывающая мьютекс, может вызывать другую функцию, которая также пытается захватить тот же мьютекс.

**Минусы**:

- Мьютекс с рекурсивной логикой тяжелее и медленнее в реализации, чем простой `std::mutex`.

## `timed_mutex` и `recursive_timed_mutex`
**Описание**:

- Является расширением обычного `std::mutex`, но позволяет вызывать методы `try_lock_for()` и `try_lock_until()`, указывая время ожидания или абсолютный момент времени ожидания.
- Если в течение заданного периода мьютекс не освободится, захват вернёт `false` вместо блокировки потока «навсегда».

**Плюсы**:

- Позволяет избежать потенциальной блокировки на неопределённое время, если есть шанс или риск дедлоков.
- Удобно применять, когда нужно работать с системами реального времени или ограниченными по времени операциями.

**Минусы**:

- Несколько выше накладные расходы, чем у обычного `std::mutex`, из-за дополнительной логики по учёту времени.

## `shared_mutex`

**Описание**:

- Поддерживает два типа захвата: эксклюзивный (write lock) и разделяемый (read lock).
  - При эксклюзивном захвате (например, метод `lock()`): только один поток может владеть мьютексом, остальные ждут.
  - При разделяемом захвате (например, метод `lock_shared()`): несколько потоков могут одновременно владеть мьютексом на чтение, при условии что никто не владеет им в режиме записи.

**Особенности**:

- Используется для реализации модели "чтение-запись" (readers-writers).
- Эксклюзивный захват блокирует все другие потоки (как чтение, так и запись).
- Общий захват позволяет нескольким потокам читать данные одновременно, но блокирует запись.

## `spin_mutex`

**Описание**:

- Мьютекс, который использует активное ожидание (spinlock) вместо блокировки потока. Поток постоянно проверяет, доступен ли мьютекс.

**Особенности**:

- Эффективен для очень коротких критических секций, где ожидание блокировки может быть дороже, чем активное ожидание.
- Может потреблять много процессорного времени, если мьютекс долго недоступен.

---

## `lock_guard`
**Описание**: Это RAII-обертка (Resource Acquisition Is Initialization) для управления захватом и освобождением мьютекса. Автоматически освобождает мьютекс при выходе из области видимости.

- При создании объекта `std::lock_guard<std::mutex> lock(m)`; происходит `m.lock()`. При выходе объекта `lock` из области видимости вызывается `m.unlock()`.

**Особенности**:

- Гарантирует автоматическое освобождение ресурса (мьютекса) даже в случае исключений или выхода из функции.

## `futex`
**Описание**:

- Это низкоуровневый механизм синхронизации в Linux, используемый внутри pthreads и стандартных реализаций мьютексов.
- «Fast userspace mutex»: ключевая идея в том, что ожидание освобождения блокировки в большинстве случаев происходит в пользовательском пространстве и переключение в режим ядра (системный вызов) нужно только тогда, когда ожидание затягивается.
- Позволяет уменьшить количество переключений в режим ядра при интенсивных блокировках/разблокировках.

**Особенности**:

- Используется для реализации более высокоуровневых мьютексов.
- Сильно привязан к конкретному ядру Linux. На других платформах futex недоступен, поэтому код на futex не является переносимым.

```{dropdown} Доронин, 2023, раздел 2
![page 12](../images/02_mtx/page-12.png)
![page 13](../images/02_mtx/page-13.png)
![page 14](../images/02_mtx/page-14.png)
![page 15](../images/02_mtx/page-15.png)
![page 16](../images/02_mtx/page-16.png)
![page 17](../images/02_mtx/page-17.png)
![page 18](../images/02_mtx/page-18.png)
![page 19](../images/02_mtx/page-19.png)
![page 20](../images/02_mtx/page-20.png)
![page 21](../images/02_mtx/page-21.png)
![page 22](../images/02_mtx/page-22.png)
![page 23](../images/02_mtx/page-23.png)
![page 24](../images/02_mtx/page-24.png)
![page 25](../images/02_mtx/page-25.png)
![page 26](../images/02_mtx/page-26.png)
![page 27](../images/02_mtx/page-27.png)
![page 28](../images/02_mtx/page-28.png)
![page 29](../images/02_mtx/page-29.png)
![page 30](../images/02_mtx/page-30.png)
![page 31](../images/02_mtx/page-31.png)
```{figure} ../images/02_mtx/page-32.png
:name:doronin-mutex
Мьютексы {cite}`доронин2023-2`
```

```{bibliography}
:style: unsrt
:filter: docname in docnames
```
